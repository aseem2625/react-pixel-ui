import React from 'react';
import { classList, prefixToClasses, debounce, scrollToHash } from 'js-awesome-utils';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _global = createCommonjsModule(function (module) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
var _core_1 = _core.version;

var _aFunction = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function (fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

var _isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function (it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

var document$1 = _global.document;
// typeof document.createElement is 'object' in old IE
var is = _isObject(document$1) && _isObject(document$1.createElement);
var _domCreate = function (it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function (it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
	f: f
};

var _propertyDesc = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && _has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? _ctx(out, _global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
var _export = $export;

var toString = {}.toString;

var _cof = function (it) {
  return toString.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings

// eslint-disable-next-line no-prototype-builtins
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// to indexed object, toObject with fallback for non-array-like ES3 strings


var _toIobject = function (it) {
  return _iobject(_defined(it));
};

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
var _toInteger = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// 7.1.15 ToLength

var min = Math.min;
var _toLength = function (it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;
var _toAbsoluteIndex = function (index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes



var _arrayIncludes = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);
    var length = _toLength(O.length);
    var index = _toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var _library = true;

var _shared = createCommonjsModule(function (module) {
var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: _core.version,
  mode: 'pure',
  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
});
});

var id = 0;
var px = Math.random();
var _uid = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var shared = _shared('keys');

var _sharedKey = function (key) {
  return shared[key] || (shared[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO = _sharedKey('IE_PROTO');

var _objectKeysInternal = function (object, names) {
  var O = _toIobject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (_has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)



var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var f$1 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$1
};

var f$2 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$2
};

// 7.1.13 ToObject(argument)

var _toObject = function (it) {
  return Object(_defined(it));
};

// 19.1.2.1 Object.assign(target, source, ...)






var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
var _objectAssign = !$assign || _fails(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = _toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = _objectGops.f;
  var isEnum = _objectPie.f;
  while (aLen > index) {
    var S = _iobject(arguments[index++]);
    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

// 19.1.3.1 Object.assign(target, source)


_export(_export.S + _export.F, 'Object', { assign: _objectAssign });

var assign = _core.Object.assign;

var assign$1 = assign;

var _extends_1 = createCommonjsModule(function (module) {
function _extends() {
  module.exports = _extends = assign$1 || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;
});

// most Object methods by ES6 should accept primitives



var _objectSap = function (KEY, exec) {
  var fn = (_core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
};

// 19.1.2.14 Object.keys(O)



_objectSap('keys', function () {
  return function keys(it) {
    return _objectKeys(_toObject(it));
  };
});

var keys = _core.Object.keys;

var keys$1 = keys;

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};

  var sourceKeys = keys$1(source);

  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);
  var keys = _objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
  return O;
};

var document$2 = _global.document;
var _html = document$2 && document$2.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



var IE_PROTO$1 = _sharedKey('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE$1 = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
  return createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE$1] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = createDict();
  return Properties === undefined ? result : _objectDps(result, Properties);
};

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
_export(_export.S, 'Object', { create: _objectCreate });

var $Object = _core.Object;
var create = function create(P, D) {
  return $Object.create(P, D);
};

var create$1 = create;

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = create$1(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var inheritsLoose = _inheritsLoose;

var Button =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(Button, _React$PureComponent);

  function Button() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto = Button.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        isRound = _this$props.isRound,
        isLink = _this$props.isLink,
        isPrimary = _this$props.isPrimary,
        iconBefore = _this$props.iconBefore,
        iconAfter = _this$props.iconAfter,
        children = _this$props.children,
        onClick = _this$props.onClick,
        className = _this$props.className,
        restProps = objectWithoutPropertiesLoose(_this$props, ["isRound", "isLink", "isPrimary", "iconBefore", "iconAfter", "children", "onClick", "className"]);

    var classes = classList('Btn', className && prefixToClasses('Btn--', className), !isLink && isRound && 'Btn--round', isLink && 'Btn--link', !isLink && isPrimary && 'Btn--primary');
    return React.createElement("button", _extends_1({}, restProps, {
      onClick: restProps.disabled ? undefined : onClick,
      className: classes
    }), iconBefore && React.createElement("i", {
      className: 'Btn-icon Btn-icon--before i-' + iconBefore
    }), children, iconAfter && React.createElement("i", {
      className: 'Btn-icon Btn-icon--after i-' + iconAfter
    }));
  };

  return Button;
}(React.PureComponent);

// true  -> String#at
// false -> String#codePointAt
var _stringAt = function (TO_STRING) {
  return function (that, pos) {
    var s = String(_defined(that));
    var i = _toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _redefine = _hide;

var _iterators = {};

var _wks = createCommonjsModule(function (module) {
var store = _shared('wks');

var Symbol = _global.Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
};

$exports.store = store;
});

var def = _objectDp.f;

var TAG = _wks('toStringTag');

var _setToStringTag = function (it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

var _iterCreate = function (Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
  _setToStringTag(Constructor, NAME + ' Iterator');
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


var IE_PROTO$2 = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

var ITERATOR = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    _hide(proto, ITERATOR, $default);
  }
  // Plug for library
  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

var $at = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

var _iterStep = function (done, value) {
  return { value: value, done: !!done };
};

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
  this._t = _toIobject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return _iterStep(1);
  }
  if (kind == 'keys') return _iterStep(0, index);
  if (kind == 'values') return _iterStep(0, O[index]);
  return _iterStep(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
_iterators.Arguments = _iterators.Array;

var TO_STRING_TAG = _wks('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = _global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
  _iterators[NAME] = _iterators.Array;
}

// getting tag from 19.1.3.6 Object.prototype.toString()

var TAG$1 = _wks('toStringTag');
// ES3 wrong here
var ARG = _cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

var _classof = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
    // builtinTag case
    : ARG ? _cof(O)
    // ES3 arguments fallback
    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

var _anInstance = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

// call something on iterator step with safe closing on error

var _iterCall = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator

var ITERATOR$1 = _wks('iterator');
var ArrayProto = Array.prototype;

var _isArrayIter = function (it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
};

var ITERATOR$2 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$2]
    || it['@@iterator']
    || _iterators[_classof(it)];
};

var _forOf = createCommonjsModule(function (module) {
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
  var f = _ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = _iterCall(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;
});

// 7.3.20 SpeciesConstructor(O, defaultConstructor)


var SPECIES = _wks('species');
var _speciesConstructor = function (O, D) {
  var C = _anObject(O).constructor;
  var S;
  return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);
};

// fast apply, http://jsperf.lnkit.com/fast-apply/5
var _invoke = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

var process = _global.process;
var setTask = _global.setImmediate;
var clearTask = _global.clearImmediate;
var MessageChannel = _global.MessageChannel;
var Dispatch = _global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (_cof(process) == 'process') {
    defer = function (id) {
      process.nextTick(_ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(_ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = _ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
    defer = function (id) {
      _global.postMessage(id + '', '*');
    };
    _global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
    defer = function (id) {
      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
        _html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(_ctx(run, id, 1), 0);
    };
  }
}
var _task = {
  set: setTask,
  clear: clearTask
};

var macrotask = _task.set;
var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
var process$1 = _global.process;
var Promise = _global.Promise;
var isNode = _cof(process$1) == 'process';

var _microtask = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process$1.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process$1.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(_global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

// 25.4.1.5 NewPromiseCapability(C)


function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = _aFunction(resolve);
  this.reject = _aFunction(reject);
}

var f$3 = function (C) {
  return new PromiseCapability(C);
};

var _newPromiseCapability = {
	f: f$3
};

var _perform = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

var navigator = _global.navigator;

var _userAgent = navigator && navigator.userAgent || '';

var _promiseResolve = function (C, x) {
  _anObject(C);
  if (_isObject(x) && x.constructor === C) return x;
  var promiseCapability = _newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var _redefineAll = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else _hide(target, key, src[key]);
  } return target;
};

var SPECIES$1 = _wks('species');

var _setSpecies = function (KEY) {
  var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];
  if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
    configurable: true,
    get: function () { return this; }
  });
};

var ITERATOR$3 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$3]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

var _iterDetect = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR$3]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR$3] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

var task = _task.set;
var microtask = _microtask();




var PROMISE = 'Promise';
var TypeError$1 = _global.TypeError;
var process$2 = _global.process;
var versions = process$2 && process$2.versions;
var v8 = versions && versions.v8 || '';
var $Promise = _global[PROMISE];
var isNode$1 = _classof(process$2) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode$1 || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && _userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(_global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = _perform(function () {
        if (isNode$1) {
          process$2.emit('unhandledRejection', value, promise);
        } else if (handler = _global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = _global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(_global, function () {
    var handler;
    if (isNode$1) {
      process$2.emit('rejectionHandled', promise);
    } else if (handler = _global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    _anInstance(this, $Promise, PROMISE, '_h');
    _aFunction(executor);
    Internal.call(this);
    try {
      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = _redefineAll($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode$1 ? process$2.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = _ctx($resolve, promise, 1);
    this.reject = _ctx($reject, promise, 1);
  };
  _newPromiseCapability.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Promise: $Promise });
_setToStringTag($Promise, PROMISE);
_setSpecies(PROMISE);
Wrapper = _core[PROMISE];

// statics
_export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
_export(_export.S + _export.F * (_library), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return _promiseResolve(this === Wrapper ? $Promise : this, x);
  }
});
_export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = _perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      _forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = _perform(function () {
      _forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

_export(_export.P + _export.R, 'Promise', { 'finally': function (onFinally) {
  var C = _speciesConstructor(this, _core.Promise || _global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return _promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return _promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

// https://github.com/tc39/proposal-promise-try




_export(_export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = _newPromiseCapability.f(this);
  var result = _perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

var promise = _core.Promise;

var promise$1 = promise;

function prevent(e) {
  e.preventDefault();
  e.stopPropagation();
}

var Spinner = function Spinner(_ref) {
  var _ref$show = _ref.show,
      show = _ref$show === void 0 ? true : _ref$show,
      isPrimary = _ref.isPrimary,
      className = _ref.className;
  return React.createElement("span", {
    className: classList('Spinner', className && prefixToClasses('Spinner--', className), show && 'Spinner--show', isPrimary && 'Spinner--primary')
  });
};

/*
* Async Button to show spinner if onClick returns promise
* @props *  - {Promise} onClick: optional, however if passed circular loader would be shown
  - Other props are passed as it is to Button component
* */

var AsyncButton =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(AsyncButton, _React$PureComponent);

  function AsyncButton() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.state = {
      isPending: false
    };

    _this.onClick = function (e) {
      if (!_this.props.onClick) {
        return;
      }

      e.persist(); // e.prevenDefault makes synthetic even to get removed. Synthetic event is needed for performance reasons

      prevent(e);

      if (!_this.state.isPending) {
        var returnValue = _this.props.onClick(e);

        if (returnValue instanceof promise$1) {
          _this.setState({
            isPending: true
          });

          returnValue.then(function (_) {
            return _this.setState({
              isPending: false
            });
          });
          returnValue.catch(function (_) {
            return _this.setState({
              isPending: false
            });
          });
        }
      }
    };

    return _this;
  }

  var _proto = AsyncButton.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.isPending !== prevProps.isPending) {
      this.setState({
        isPending: this.props.isPending
      }); // In case of onSubmit, <Form> would control state of <AsyncButton>
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        pendingText = _this$props.pendingText,
        onClick = _this$props.onClick,
        _this$props$showSpinn = _this$props.showSpinner,
        showSpinner = _this$props$showSpinn === void 0 ? true : _this$props$showSpinn,
        children = _this$props.children,
        className = _this$props.className,
        disabled = _this$props.disabled,
        pending = _this$props.isPending,
        restProps = objectWithoutPropertiesLoose(_this$props, ["pendingText", "onClick", "showSpinner", "children", "className", "disabled", "isPending"]);

    var isPending = this.state.isPending;
    return React.createElement(Button, _extends_1({}, restProps, {
      className: classList('AsyncBtn', className, isPending && 'AsyncBtn--isPending'),
      onClick: onClick && !disabled ? this.onClick : void 0,
      disabled: isPending || disabled
    }), React.createElement("span", {
      className: "Btn-mainText"
    }, children), pendingText && React.createElement("span", {
      className: "Btn-pendingText"
    }, pendingText), showSpinner && React.createElement(Spinner, {
      show: isPending,
      isPrimary: !restProps.isPrimary || restProps.isLink
    }));
  };

  return AsyncButton;
}(React.PureComponent);

var RipplePointer = function RipplePointer(_ref) {
  var _ref$isPrimary = _ref.isPrimary,
      isPrimary = _ref$isPrimary === void 0 ? false : _ref$isPrimary,
      className = _ref.className,
      onClick = _ref.onClick,
      restProps = objectWithoutPropertiesLoose(_ref, ["isPrimary", "className", "onClick"]);

  return React.createElement("div", _extends_1({}, restProps, {
    className: classList('RipplePointer', isPrimary && 'RipplePointer--primary', prefixToClasses('RipplePointer--', className), onClick && 'RipplePointer--clickable')
  }), React.createElement("span", {
    className: "RipplePointer-epicenter",
    onClick: onClick
  }));
};

var HelpText = function HelpText(_ref) {
  var children = _ref.children,
      _ref$isLarge = _ref.isLarge,
      isLarge = _ref$isLarge === void 0 ? false : _ref$isLarge;
  return React.createElement("div", {
    className: classList('HelpText', isLarge && 'HelpText--large')
  }, React.createElement("span", {
    className: "HelpText-content"
  }, children));
};

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var assertThisInitialized = _assertThisInitialized;

/*
 *
 * */

var Tooltip =
/*#__PURE__*/
function (_React$Component) {
  inheritsLoose(Tooltip, _React$Component);

  // default delay = 0ms
  function Tooltip(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {};
    _this.delay = _this.props.delay || 0;
    _this.onMouseEnter = _this._onMouseEnter.bind(assertThisInitialized(_this));
    _this.onMouseLeave = _this._onMouseLeave.bind(assertThisInitialized(_this));
    return _this;
  }

  var _proto = Tooltip.prototype;

  _proto._onMouseEnter = function _onMouseEnter(e) {
    this.setPosition();
  } // Location aware positioning
  ;

  _proto.setPosition = function setPosition() {};

  _proto._onMouseLeave = function _onMouseLeave(e) {
    this.props.onMouseLeave && this.props.onMouseLeave();
  };

  _proto.render = function render() {
    var _this$props = this.props,
        className = _this$props.className,
        children = _this$props.children,
        tooltipText = _this$props.tooltipText;
    return React.createElement("div", {
      className: classList('Tooltip', prefixToClasses('Tooltip--', className))
    }, React.createElement("span", {
      className: "Tooltip-trigger",
      onMouseEnter: this.onMouseEnter,
      onMouseLeave: this.onMouseLeave
    }, children), React.createElement("span", {
      className: "Tooltip-text"
    }, tooltipText));
  };

  return Tooltip;
}(React.Component);

var OutsideClickLayer =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(OutsideClickLayer, _React$PureComponent);

  function OutsideClickLayer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;

    _this.handleClick = function (e) {
      if (_this.layer && !_this.layer.contains(e.target)) {
        _this.props.onOutsideClick();
      }
    };

    _this.addListener = function () {
      document.addEventListener('mouseup', _this.handleClick);
    };

    _this.removeListener = function () {
      document.removeEventListener('mouseup', _this.handleClick);
    };

    _this.setRef = function (e) {
      return _this.layer = e;
    };

    return _this;
  }

  var _proto = OutsideClickLayer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.enabled) {
      this.addListener();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.removeListener();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.enabled !== this.props.enabled) {
      this.props.enabled ? this.addListener() : this.removeListener();
    }
  };

  _proto.render = function render() {
    var children = this.props.children;
    return React.createElement("div", {
      ref: this.setRef
    }, children);
  };

  return OutsideClickLayer;
}(React.PureComponent);

/*
 *
 * */

var Popover =
/*#__PURE__*/
function (_React$Component) {
  inheritsLoose(Popover, _React$Component);

  function Popover() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {};
    _this.delay = 250;
    _this.showPopover = _this._showPopover.bind(assertThisInitialized(_this));
    _this.hidePopover = _this._hidePopover.bind(assertThisInitialized(_this));
    _this.clearInterval = _this._clearInterval.bind(assertThisInitialized(_this));
    return _this;
  }

  var _proto = Popover.prototype;

  // Delay = 250ms (not taken from props to make consistent)
  _proto._showPopover = function _showPopover(e) {
    var _this2 = this;

    // No delay if the trigger is click
    if (!this.props.triggerOnHover) {
      this.setState({
        show: true
      });
    } else {
      this.inTransition = window.setTimeout(function (_) {
        _this2.inTransition && _this2.setState({
          show: true
        });
      }, this.delay);
    }
  };

  _proto._hidePopover = function _hidePopover(e) {
    this.setState({
      show: false
    });
  };

  _proto._clearInterval = function _clearInterval() {
    this.inTransition && window.clearTimeout(this.inTransition);
  };

  _proto.render = function render() {
    var _this$props = this.props,
        className = _this$props.className,
        children = _this$props.children,
        content = _this$props.content,
        _this$props$triggerOn = _this$props.triggerOnHover,
        triggerOnHover = _this$props$triggerOn === void 0 ? false : _this$props$triggerOn;
    return React.createElement(OutsideClickLayer, {
      onOutsideClick: this.hidePopover,
      enabled: true
    }, React.createElement("div", {
      className: classList('Popover', this.state.show && 'Popover--show', prefixToClasses('Popover--', className))
    }, this.state.show && React.createElement("span", {
      className: "Popover-content"
    }, content(this.hidePopover)), React.createElement("span", {
      className: "Popover-trigger",
      onClick: triggerOnHover ? undefined : this.showPopover,
      onMouseOver: triggerOnHover ? this.showPopover : undefined,
      onMouseOut: triggerOnHover ? this.clearInterval : undefined
    }, children)));
  };

  return Popover;
}(React.Component);

function getFieldClasses(props) {
  var className = props.className;
  return classList('Field', prefixToClasses('Field--', classList(className, getFieldWrapperClasses(props))));
}
/*
 * TODO: defaultValue, validator, tooltips onHover/onClick,
 *
 * */

var Field =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(Field, _React$PureComponent);

  function Field() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto = Field.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        tag = _this$props.tag,
        className = _this$props.className,
        name = _this$props.name,
        placeholder = _this$props.placeholder,
        disabled = _this$props.disabled,
        required = _this$props.required,
        children = _this$props.children,
        onChange = _this$props.onChange,
        onFocus = _this$props.onFocus,
        onBlur = _this$props.onBlur,
        elRef = _this$props.elRef,
        restProps = objectWithoutPropertiesLoose(_this$props, ["tag", "className", "name", "placeholder", "disabled", "required", "children", "onChange", "onFocus", "onBlur", "elRef"]);

    var InputTag = tag || 'input'; // tag = select, textarea, input

    return React.createElement("div", {
      className: getFieldClasses(this.props)
    }, React.createElement(InputTag, _extends_1({}, restProps, {
      // style, other Listeners
      className: "Field-el",
      name: name,
      placeholder: placeholder,
      disabled: disabled,
      required: required,
      onChange: onChange,
      onFocus: onFocus,
      onBlur: onBlur,
      ref: elRef
    })), children);
  };

  return Field;
}(React.PureComponent);
function getFieldWrapperClasses(props, state) {
  if (state === void 0) {
    state = {};
  }

  var disabled = props.disabled,
      required = props.required;
  var _state = state,
      isFocused = _state.isFocused,
      isMature = _state.isMature,
      error = _state.error;
  return classList(disabled && 'disabled', required && 'required', isFocused && 'focused', isMature && 'mature', error && 'invalid');
}
/*
 *
 * */

function addWrapperToField(_FieldComponent, _fieldType) {
  return (
    /*#__PURE__*/
    function (_React$PureComponent2) {
      inheritsLoose(_class, _React$PureComponent2);

      function _class(props) {
        var _this;

        _this = _React$PureComponent2.call(this, props) || this;
        _this.class = 'FieldWrapper';
        _this.state = {
          error: '',
          isMature: false,
          isFocused: false
        };
        _this.onChange = _this._onChange.bind(assertThisInitialized(_this));
        _this.onFocus = _this._onFocus.bind(assertThisInitialized(_this));
        _this.onBlur = _this._onBlur.bind(assertThisInitialized(_this));
        return _this;
      }

      var _proto2 = _class.prototype;

      _proto2.componentDidMount = function componentDidMount() {
        this.evalValidity(); // error is evaluated in start, even though it may be displayed only when isMature.
        // On render, FE error will be shown upfront if value filled is not value.

        if (this.props.defaultValue || this.props.value) {
          this.setState({
            isMature: true
          });
        }
      } // TODO: Debounce
      ;

      _proto2.evalValidity = function evalValidity() {
        // TODO: evaluation logic
        var error = '';
        this.setState({
          error: error
        });
      };

      _proto2._onFocus = function _onFocus() {
        this.setState({
          isFocused: true
        });
        this.props.onFocus && this.props.onFocus(e);
      };

      _proto2._onBlur = function _onBlur() {
        this.setState({
          isFocused: false
        });
        /*
         * Setting mature shows the error. However, mature is done only when the field is isDirty and also, blurred.
         * So, error on mature is shown only when it has isDirty + blurred once.
         * */

        if (this.state.isDirty) {
          this.setState({
            isMature: true
          });
        }

        this.props.onBlur && this.props.onBlur(e);
      };

      _proto2._onChange = function _onChange(e) {
        this.evalValidity();
        this.props.onChange && this.props.onChange(e);

        if (!this.state.isMature || !this.state.isDirty) {
          this.setState({
            isDirty: true
          });
        }
      };

      _proto2.render = function render() {
        var _this$props2 = this.props,
            className = _this$props2.className,
            label = _this$props2.label,
            description = _this$props2.description,
            children = _this$props2.children,
            restProps = objectWithoutPropertiesLoose(_this$props2, ["className", "label", "description", "children"]);

        var error = this.state.error;
        return React.createElement("div", {
          className: classList(this.class, className && prefixToClasses(this.class + "--", className), _fieldType && prefixToClasses(this.class + "--", _fieldType), prefixToClasses(this.class + "--", getFieldWrapperClasses(this.props, this.state)))
        }, label && React.createElement("div", {
          className: "Field-label"
        }, label, restProps.required && React.createElement("span", {
          className: "Field-label-star"
        }, "*")), React.createElement("div", {
          className: "Field-content"
        }, React.createElement(_FieldComponent, _extends_1({}, restProps, {
          onError: this.onError,
          onChange: this.onChange,
          onFocus: this.onFocus,
          onBlur: this.onBlur
        }), children), React.createElement("div", {
          className: "Field-error"
        }, error || ''), React.createElement("div", {
          className: "Field-description"
        }, description || '')));
      };

      return _class;
    }(React.PureComponent)
  );
}

/*
 *
 *
 * */

var TextareaElement =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(TextareaElement, _React$PureComponent);

  function TextareaElement() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.onInput = _this._onInput.bind(assertThisInitialized(_this));
    _this.disableEnterPress = _this._disableEnterPress.bind(assertThisInitialized(_this));

    _this.setRef = function (e) {
      return _this.resizerEl = e;
    };

    _this.setElRef = function (e) {
      _this.el = _this.props.setElRef ? _this.props.setElRef(e) : e;
    };

    return _this;
  }

  var _proto = TextareaElement.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.autoResize && this.autoAdjustHeight(this.el);
  };

  _proto.autoAdjustHeight = function autoAdjustHeight(target) {
    if (!target) {
      return;
    }

    var content = target.value;
    var resizerEl = this.resizerEl;
    resizerEl.value = content;
    var newHeight = resizerEl.scrollHeight;
    target.style.height = newHeight + 'px';
  };

  _proto._onInput = function _onInput(e) {
    if (this.props.autoResize) {
      this.autoAdjustHeight(e.target);
    }

    this.props.onInput && this.props.onInput(e);
  };

  _proto._disableEnterPress = function _disableEnterPress(e) {
    if (e.which === 13) {
      // Enter
      e.preventDefault();
      return;
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        autoResize = _this$props.autoResize,
        disableEnterPress = _this$props.disableEnterPress,
        className = _this$props.className,
        setElRef = _this$props.setElRef,
        restProps = objectWithoutPropertiesLoose(_this$props, ["autoResize", "disableEnterPress", "className", "setElRef"]);

    return React.createElement(Field, _extends_1({}, restProps, {
      className: classList('Textarea', className),
      tag: "textarea",
      onInput: this.onInput,
      onKeyPress: disableEnterPress ? this.disableEnterPress : undefined,
      elRef: this.setElRef
    }), autoResize && React.createElement("textarea", {
      className: "Textarea-resizer",
      ref: this.setRef,
      readOnly: true
    }));
  };

  return TextareaElement;
}(React.PureComponent);
TextareaElement.defaultProps = {
  autoResize: false,
  disableEnterPress: false
};
/*
 *
 *
 * */

var Textarea = addWrapperToField(TextareaElement, 'Textarea');

function Clipboard(type) {
  var _temp;

  var _WrappedComponent;

  var HOC = (_temp =
  /*#__PURE__*/
  function (_React$PureComponent) {
    inheritsLoose(HOC, _React$PureComponent);

    function HOC(props) {
      var _this;

      _this = _React$PureComponent.call(this, props) || this;

      _this.setRef = function (e) {
        return _this.copierEl = e;
      };

      _this.state = {
        isCopied: null,
        isCopySupported: false
      };
      _this.copyToClipboard = _this._copyToClipboard.bind(assertThisInitialized(_this));

      if (type === 'withTooltip') {
        _this.onMouseLeave = _this._onMouseLeave.bind(assertThisInitialized(_this));
      }

      return _this;
    }

    var _proto = HOC.prototype;

    _proto.componentDidMount = function componentDidMount() {
      if (document.execCommand) {
        this.setState({
          isCopySupported: true
        });
      }
    };

    _proto.selectValue = function selectValue() {
      if (this.copierEl.select) {
        this.copierEl.select();
        this.setState({
          isCopied: true
        });
      }
    };

    _proto._copyToClipboard = function _copyToClipboard() {
      var _this2 = this;

      this.selectValue();
      document.execCommand('copy');
      setTimeout(function (_) {
        _this2.setState({
          isCopied: false
        });
      }, 1500);
      this.props.onCopy && this.props.onCopy();
    };

    _proto._onMouseLeave = function _onMouseLeave() {
      this.setState({
        isCopied: false
      });
    };

    _proto.render = function render() {
      var _this$props = this.props,
          className = _this$props.className,
          toCopy = _this$props.toCopy,
          restProps = objectWithoutPropertiesLoose(_this$props, ["className", "toCopy"]);

      var _this$state = this.state,
          isCopied = _this$state.isCopied,
          isCopySupported = _this$state.isCopySupported;

      if (!isCopySupported) {
        return null;
      }

      return React.createElement("span", {
        className: classList('Clipboard', "Clipboard--" + type, prefixToClasses('Clipboard--', className), isCopied && 'Clipboard--copied'),
        onClick: this.copyToClipboard
      }, React.createElement(TextareaElement, {
        setElRef: this.setRef,
        className: "Clipboard-input",
        value: toCopy,
        readOnly: true
      }), React.createElement(_WrappedComponent, _extends_1({}, restProps, {
        isCopied: isCopied,
        onMouseLeave: this.onMouseLeave
      })));
    };

    return HOC;
  }(React.PureComponent), _temp);
  return function (_component) {
    _WrappedComponent = _component;
    return HOC;
  };
}
/*
 *
 *
 * */


function _ClipboardWithButton(_ref) {
  var isCopied = _ref.isCopied,
      buttonCopyText = _ref.buttonCopyText,
      _ref$buttonCopiedText = _ref.buttonCopiedText,
      buttonCopiedText = _ref$buttonCopiedText === void 0 ? 'Copied!' : _ref$buttonCopiedText;
  return React.createElement(Button, {
    className: "Clipboard-copyButton"
  }, isCopied ? buttonCopiedText : buttonCopyText);
}

var ClipboardWithButton = Clipboard('withButton')(_ClipboardWithButton);
/*
 *
 *
 * */

function _ClipboardWithTooltip(_ref2) {
  var children = _ref2.children,
      isCopied = _ref2.isCopied,
      tooltipCopyText = _ref2.tooltipCopyText,
      _ref2$tooltipCopiedTe = _ref2.tooltipCopiedText,
      tooltipCopiedText = _ref2$tooltipCopiedTe === void 0 ? 'Copied!' : _ref2$tooltipCopiedTe,
      onMouseLeave = _ref2.onMouseLeave;
  return React.createElement(Tooltip, {
    tooltipText: isCopied ? tooltipCopiedText : tooltipCopyText,
    onMouseLeave: onMouseLeave
  }, children);
}

var ClipboardWithTooltip = Clipboard('withTooltip')(_ClipboardWithTooltip);

function TagsList(_ref) {
  var className = _ref.className,
      children = _ref.children;
  return React.createElement("div", {
    className: classList('TagsList', prefixToClasses('TagsList--', className))
  }, children);
}

function Tag(_ref) {
  var children = _ref.children,
      className = _ref.className;
  return React.createElement("div", {
    className: classList('Tag', prefixToClasses('Tag--', className))
  }, children);
}

var AutoRemoveLayer =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(AutoRemoveLayer, _React$PureComponent);

  function AutoRemoveLayer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.state = {};
    _this.handleRemove = _this._handleRemove.bind(assertThisInitialized(_this));
    return _this;
  }

  var _proto = AutoRemoveLayer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.startAutoRemove();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.removeTimer && clearTimeout(this.removeTimer);
  };

  _proto.startAutoRemove = function startAutoRemove() {
    var _this2 = this;

    if (this.props.enabled) {
      var autoRemoveDuration = this.props.duration || 3000; // 3s is default duration to hide a given item in stack

      this.removeTimer = setTimeout(function (_) {
        _this2.setState({
          hide: true
        });

        setTimeout(_this2.handleRemove, 500);
      }, autoRemoveDuration);
    }
  };

  _proto._handleRemove = function _handleRemove() {
    this.props.remove(this.props.id);
  };

  _proto.render = function render() {
    return React.createElement("div", {
      className: classList(this.state.hide && "isHidden")
    }, this.props.children);
  };

  return AutoRemoveLayer;
}(React.PureComponent);

/*
 *
 * */

var Stack =
/*#__PURE__*/
function (_React$Component) {
  inheritsLoose(Stack, _React$Component);

  function Stack() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      stack: []
    };
    _this.stackType = 'Stack';

    _this.removeItemFromStack = function (id) {
      var stack = _this.state.stack;
      var indexToRemove;

      for (var i = 0; i < stack.length; i++) {
        if (stack[i].id === id) {
          indexToRemove = i;
          break;
        }
      }

      stack.splice(indexToRemove, 1); // Directly mutating the state
      // Just to trigger re-render

      _this.setState({
        stack: stack
      });
    };

    return _this;
  }

  var _proto = Stack.prototype;

  _proto.addItemInStack = function addItemInStack(opts, reverseOrder) {
    var stack = this.state.stack;
    var stackOrder = reverseOrder ? 'push' : 'unshift'; // By default stack will add in the starting
    // Directly mutating the state

    stack[stackOrder](assign$1({
      // Adding in starting of the stack
      id: this.stackType + "-" + new Date().getTime()
    }, opts)); // Just to trigger re-render

    this.setState({
      stack: stack
    });
  };

  return Stack;
}(React.Component);
var StackItem =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(StackItem, _React$PureComponent);

  function StackItem() {
    var _this2;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this2.handleRemove = _this2._handleRemove.bind(assertThisInitialized(_this2));
    return _this2;
  }

  var _proto2 = StackItem.prototype;

  _proto2._handleRemove = function _handleRemove() {
    this.props.removeItemFromStack(this.props.id);
  };

  _proto2.render = function render() {
    var _this$props = this.props,
        className = _this$props.className,
        _this$props$stackItem = _this$props.stackItemType,
        stackItemType = _this$props$stackItem === void 0 ? 'StackItem' : _this$props$stackItem,
        showCross = _this$props.showCross,
        children = _this$props.children;
    return React.createElement("div", {
      className: classList(stackItemType, prefixToClasses(stackItemType + "--", className))
    }, React.createElement("span", {
      className: stackItemType + "-content"
    }, typeof children === 'function' ? children(this.handleRemove) : children), !!showCross && React.createElement("span", {
      className: stackItemType + "-cross",
      onClick: this.handleRemove
    }, "\xD7"));
  };

  return StackItem;
}(React.PureComponent);

var _toastsStackInstance;
/*
 *
 * By default auto hide is on for Toast
 * */


var ToastsContainer =
/*#__PURE__*/
function (_Stack) {
  inheritsLoose(ToastsContainer, _Stack);

  function ToastsContainer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Stack.call.apply(_Stack, [this].concat(args)) || this;
    _this.stackType = 'Toast';
    return _this;
  }

  var _proto = ToastsContainer.prototype;

  // Override stackType
  _proto.componentDidMount = function componentDidMount() {
    _toastsStackInstance = this;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    _toastsStackInstance = null;
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement("div", {
      className: "ToastsContainer"
    }, this.state.stack.map(function (t, ix) {
      // By default auto remove is ON for Toast
      var isEnabledAutoRemove = typeof t.enableAutoRemove !== 'undefined' ? !!t.enableAutoRemove : true;
      return React.createElement(AutoRemoveLayer, {
        key: t.id,
        duration: t.duration,
        remove: _this2.removeItemFromStack,
        enabled: isEnabledAutoRemove
      }, React.createElement(StackItem, {
        stackItemType: _this2.stackType,
        id: t.id,
        className: t.type,
        showCross: t.showCross,
        removeItemFromStack: _this2.removeItemFromStack
      }, t.content));
    }));
  };

  return ToastsContainer;
}(Stack);
function openToast(_ref) {
  var content = _ref.content,
      type = _ref.type,
      duration = _ref.duration,
      showCross = _ref.showCross;

  _toastsStackInstance.addItemInStack({
    content: content,
    type: type,
    duration: duration,
    showCross: showCross
  });
}

var _notificationsStackInstance;
/*
 *
 * */


var NotificationsContainer =
/*#__PURE__*/
function (_Stack) {
  inheritsLoose(NotificationsContainer, _Stack);

  function NotificationsContainer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Stack.call.apply(_Stack, [this].concat(args)) || this;
    _this.stackType = 'Notification';
    return _this;
  }

  var _proto = NotificationsContainer.prototype;

  // Override stackType
  _proto.componentDidMount = function componentDidMount() {
    _notificationsStackInstance = this;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    _notificationsStackInstance = null;
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement("div", {
      className: "NotificationsContainer"
    }, this.state.stack.map(function (n, ix) {
      // By default auto remove is ON for Notification
      var isEnabledAutoRemove = typeof n.enableAutoRemove !== 'undefined' ? !!n.enableAutoRemove : true;
      return React.createElement(AutoRemoveLayer, {
        key: n.id,
        duration: n.duration,
        remove: _this2.removeItemFromStack,
        enabled: isEnabledAutoRemove
      }, React.createElement(StackItem, {
        stackItemType: _this2.stackType,
        id: n.id,
        showCross: n.showCross,
        removeItemFromStack: _this2.removeItemFromStack,
        className: n.className
      }, n.content));
    }));
  };

  return NotificationsContainer;
}(Stack);
function openNotification(props) {
  _notificationsStackInstance.addItemInStack(props);
}

var EscPressLayer =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(EscPressLayer, _React$PureComponent);

  function EscPressLayer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.handleEsc = _this._handleEsc.bind(assertThisInitialized(_this));

    _this.addListener = function () {
      document.addEventListener('keydown', _this.handleEsc);
    };

    _this.removeListener = function () {
      document.removeEventListener('keydown', _this.handleEsc);
    };

    return _this;
  }

  var _proto = EscPressLayer.prototype;

  _proto._handleEsc = function _handleEsc(e) {
    e = e || window.event;
    var isEscape = false;

    if ('key' in e) {
      isEscape = e.key === 'Escape' || e.key === 'Esc';
    } else {
      isEscape = e.keyCode === 27;
    }

    if (isEscape) {
      this.props.onEscPress();
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.enabled) {
      this.addListener();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.removeListener();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.enabled !== this.props.enabled) {
      this.props.enabled ? this.addListener() : this.removeListener();
    }
  };

  _proto.render = function render() {
    var children = this.props.children;
    return React.createElement("div", null, children);
  };

  return EscPressLayer;
}(React.PureComponent);

/*
 * Usage: <BackDrop>{content}</BackDrop>
 * Props:
 *   show
 *   className
 * */

var BackDrop =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(BackDrop, _React$PureComponent);

  function BackDrop() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto = BackDrop.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.show) {
      this.freezeBG();
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    if (this.props.show) {
      this.freezeBG();
    } else {
      this.unFreezeBG();
    }
  };

  _proto.freezeBG = function freezeBG() {
    document.body.classList.add('freeze');
    document.getElementById('root').classList.add('freeze');
  };

  _proto.unFreezeBG = function unFreezeBG() {
    document.body.classList.remove('freeze');
    document.getElementById('root').classList.remove('freeze');
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.unFreezeBG();
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        _this$props$show = _this$props.show,
        show = _this$props$show === void 0 ? false : _this$props$show,
        className = _this$props.className;
    return React.createElement("div", {
      className: classList('BackDrop', show && 'BackDrop--show', prefixToClasses('BackDrop--', className))
    }, React.createElement("div", {
      className: "BackDrop-content"
    }, children));
  };

  return BackDrop;
}(React.PureComponent);

var _popupsStackInstance;
/*
 *
 * No auto removal for Popups
 * */

var PopupsContainer =
/*#__PURE__*/
function (_Stack) {
  inheritsLoose(PopupsContainer, _Stack);

  function PopupsContainer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Stack.call.apply(_Stack, [this].concat(args)) || this;
    _this.stackType = 'Popup';
    return _this;
  }

  var _proto = PopupsContainer.prototype;

  // Override stackType
  _proto.componentDidMount = function componentDidMount() {
    _popupsStackInstance = this;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    _popupsStackInstance = null;
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(BackDrop, {
      className: "Popup",
      show: this.state.stack.length
    }, this.state.stack.map(function (p, ix) {
      var isEnabledOutsideClick = p.enableOutsideClick || false; // By default it's false

      var isEnabledEscPress = p.enableEscPress || false; // By default it's false

      return React.createElement(OutsideClickLayer, {
        key: p.id,
        onOutsideClick: function onOutsideClick(_) {
          return _this2.removeItemFromStack(p.id);
        },
        enabled: isEnabledOutsideClick && ix === _this2.state.stack.length - 1 // Only last Popup is allowed to be closed on outside click

      }, React.createElement(EscPressLayer, {
        onEscPress: function onEscPress(_) {
          return _this2.removeItemFromStack(p.id);
        },
        enabled: isEnabledEscPress && ix === _this2.state.stack.length - 1 // Only last Popup is allowed to be closed on ecs press

      }, React.createElement(StackItem, {
        stackItemType: _this2.stackType,
        id: p.id,
        showCross: p.showCross,
        removeItemFromStack: _this2.removeItemFromStack,
        className: p.className
      }, p.title && React.createElement("div", {
        className: classList(_this2.stackType + "--title")
      }, p.title), React.createElement("div", {
        className: classList(_this2.stackType + "--body")
      }, typeof p.content === 'function' ? p.content(function (_) {
        return _this2.removeItemFromStack(p.id);
      }) : p.content))));
    }));
  };

  return PopupsContainer;
}(Stack);
/*
 * Props:
 *   title
 *   content
 *   className
 *   showCross
 *   enableEscPress
 *   enableOutsideClick
 *
 * */

function openPopup(props) {
  _popupsStackInstance.addItemInStack(props, true);
}

/*
 * Props:
 *   description,
 *   cancelLabel,
 *   affirmLabel,
 *   onAffirm,
 *   onCancel
 * */

var ConfirmPopup =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(ConfirmPopup, _React$PureComponent);

  function ConfirmPopup() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.onCancel = _this._onCancel.bind(assertThisInitialized(_this));
    _this.onAffirm = _this._onAffirm.bind(assertThisInitialized(_this));
    return _this;
  }

  var _proto = ConfirmPopup.prototype;

  _proto._onCancel = function _onCancel() {
    this.props.close();
    this.props.onCancel && this.props.onCancel();
    this.props.reject();
  };

  _proto._onAffirm = function _onAffirm() {
    var _this2 = this;

    this.props.close();

    if (this.props.onAffirm) {
      var promise = this.props.onAffirm();

      if (promise.then) {
        promise.then(function (resp) {
          _this2.props.resolve(resp);
        });
      } else {
        this.props.resolve();
      }
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        description = _this$props.description,
        affirmLabel = _this$props.affirmLabel,
        cancelLabel = _this$props.cancelLabel,
        className = _this$props.className;
    return React.createElement(React.Fragment, null, description && React.createElement("div", {
      className: prefixToClasses('Popup--', className + '-description')
    }, description), React.createElement("div", {
      className: prefixToClasses('Popup--', className + '-actions')
    }, React.createElement(Button, {
      onClick: this.onCancel
    }, cancelLabel), React.createElement(Button, {
      isPrimary: true,
      onClick: this.onAffirm
    }, affirmLabel)));
  };

  return ConfirmPopup;
}(React.PureComponent);
/*
 * Props:
 *   title,
 *   description,
 *   affirmLabel,
 *   cancelLabel,
 *   onAffirm,
 *   onCancel
 *
 * */


function openConfirmPopup(_ref) {
  var description = _ref.description,
      affirmLabel = _ref.affirmLabel,
      cancelLabel = _ref.cancelLabel,
      onAffirm = _ref.onAffirm,
      onCancel = _ref.onCancel,
      className = _ref.className,
      restProps = objectWithoutPropertiesLoose(_ref, ["description", "affirmLabel", "cancelLabel", "onAffirm", "onCancel", "className"]);

  var cls = 'Confirm';
  return new promise$1(function (res, rej) {
    _popupsStackInstance.addItemInStack(assign$1({}, restProps, {
      className: classList(cls, className),
      content: function content(close) {
        return React.createElement(ConfirmPopup, {
          className: cls,
          close: close,
          description: description,
          affirmLabel: affirmLabel,
          cancelLabel: cancelLabel,
          onAffirm: onAffirm,
          onCancel: onCancel,
          resolve: res,
          reject: rej
        });
      },
      showCross: false,
      enableEscPress: false,
      enableOutsideClick: false
    }), true);
  }).catch(function (err) {});
}

var GhostLoader = function GhostLoader(_ref) {
  var className = _ref.className,
      _ref$animate = _ref.animate,
      animate = _ref$animate === void 0 ? false : _ref$animate;
  return React.createElement("div", {
    className: classList('GhostLoader', animate && 'GhostLoader--animate', prefixToClasses('GhostLoader--', className))
  });
};

var Dropdown =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(Dropdown, _React$PureComponent);

  function Dropdown(props) {
    var _this;

    _this = _React$PureComponent.call(this, props) || this;

    _this.setBodyRef = function (e) {
      return _this.optionsBody = e;
    };

    _this.state = {
      show: props.show || false
    };
    _this.toggleDropdown = _this._toggleDropdown.bind(assertThisInitialized(_this));
    _this.closeDropdown = _this._closeDropdown.bind(assertThisInitialized(_this));
    return _this;
  }

  var _proto = Dropdown.prototype;

  _proto._toggleDropdown = function _toggleDropdown(forceSet) {
    var _this2 = this;

    var toShow = typeof forceSet === 'boolean' ? forceSet : !this.state.show;
    this.setState({
      show: toShow
    }, function () {
      if (toShow) {
        _this2.rePositionBody();
      }
    });
  };

  _proto.componentDidMount = function componentDidMount() {
    if (this.state.show) {
      this.rePositionBody();
    }
  };

  _proto.rePositionBody = function rePositionBody() {
    var el = this.optionsBody;
    var renderWidthWithFixed = el && el.getBoundingClientRect().width;
    el.style.width = renderWidthWithFixed + 'px';
    el.style.position = 'absolute';
    el.style.opacity = 1;
  };

  _proto._closeDropdown = function _closeDropdown() {
    this.toggleDropdown(false);
  };

  _proto.render = function render() {
    var _this3 = this;

    var _this$props = this.props,
        showOnHover = _this$props.showOnHover,
        className = _this$props.className,
        trigger = _this$props.trigger,
        beforeOptions = _this$props.beforeOptions,
        afterOptions = _this$props.afterOptions,
        children = _this$props.children;
    var show = this.state.show;
    return React.createElement(OutsideClickLayer, {
      onOutsideClick: function onOutsideClick(_) {
        return _this3.setState({
          show: false
        });
      },
      enabled: !showOnHover
    }, React.createElement("div", {
      className: classList('Dropdown', show && 'Dropdown--show', prefixToClasses('Dropdown--', className)),
      onMouseEnter: showOnHover ? this.toggleDropdown : undefined,
      onMouseLeave: showOnHover ? this.closeDropdown : undefined
    }, React.createElement("div", {
      ref: this.setTriggerRef,
      className: "Dropdown-trigger",
      onClick: showOnHover ? undefined : this.toggleDropdown
    }, typeof trigger === 'function' ? trigger() : trigger), this.state.show && React.createElement(DropdownOptions, {
      elRef: this.setBodyRef,
      beforeOptions: beforeOptions,
      afterOptions: afterOptions,
      closeDropdown: this.closeDropdown
    }, children)));
  };

  return Dropdown;
}(React.PureComponent);
var DropdownOptions =
/*#__PURE__*/
function (_React$PureComponent2) {
  inheritsLoose(DropdownOptions, _React$PureComponent2);

  function DropdownOptions() {
    return _React$PureComponent2.apply(this, arguments) || this;
  }

  var _proto2 = DropdownOptions.prototype;

  _proto2.render = function render() {
    var _this$props2 = this.props,
        beforeOptions = _this$props2.beforeOptions,
        afterOptions = _this$props2.afterOptions,
        children = _this$props2.children,
        elRef = _this$props2.elRef,
        closeDropdown = _this$props2.closeDropdown;
    return React.createElement("div", {
      ref: elRef,
      className: "DropdownBody"
    }, !!beforeOptions && React.createElement("div", {
      className: "DropdownOptions-before"
    }, typeof beforeOptions === 'function' ? beforeOptions(closeDropdown) : beforeOptions), React.createElement("div", {
      className: "DropdownOptions"
    }, typeof children === 'function' ? children(closeDropdown) : children), !!afterOptions && React.createElement("div", {
      className: "DropdownOptions-after"
    }, typeof afterOptions === 'function' ? afterOptions(closeDropdown) : afterOptions));
  };

  return DropdownOptions;
}(React.PureComponent);
var DropdownItem = function DropdownItem(_ref) {
  var children = _ref.children,
      className = _ref.className,
      restProps = objectWithoutPropertiesLoose(_ref, ["children", "className"]);

  return React.createElement("div", _extends_1({
    className: classList('DropdownItem', className)
  }, restProps), children);
};

var Card =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(Card, _React$PureComponent);

  function Card() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto = Card.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        className = _this$props.className,
        animate = _this$props.animate,
        hasShadow = _this$props.hasShadow,
        children = _this$props.children;
    return React.createElement("div", {
      className: classList('Card', animate && 'Card--animate', hasShadow && 'Card--shadow', prefixToClasses('Card--', className))
    }, children);
  };

  return Card;
}(React.PureComponent);

var Banner = function Banner(_ref) {
  var className = _ref.className,
      type = _ref.type,
      children = _ref.children;
  return React.createElement("div", {
    className: classList('Banner', type && "Banner--" + type, prefixToClasses('Banner--', className))
  }, children);
};

var _createProperty = function (object, index, value) {
  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
  else object[index] = value;
};

_export(_export.S + _export.F * !_iterDetect(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = _toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = core_getIteratorMethod(O);
    var length, result, step, iterator;
    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = _toLength(O.length);
      for (result = new C(length); length > index; index++) {
        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

var from_1 = _core.Array.from;

var from_1$1 = from_1;

var Form =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(Form, _React$PureComponent);

  function Form() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.state = {
      isPending: false
    };

    _this.setRef = function (e) {
      return _this.form = e;
    };

    _this.evaluateIfError = debounce(_this._evaluateIfError.bind(assertThisInitialized(_this)), 50);
    _this.onChange = _this._onChange.bind(assertThisInitialized(_this));
    _this.onSubmit = _this._onSubmit.bind(assertThisInitialized(_this));
    return _this;
  }

  var _proto = Form.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.evaluateIfError();
  };

  _proto._evaluateIfError = function _evaluateIfError() {
    var hasInvalidField = this.form.querySelector('.Input.isInvalid');
    this.setState({
      isInvalid: hasInvalidField
    });
    return hasInvalidField;
  };

  _proto._onSubmit = function _onSubmit(e) {
    var _this2 = this;

    e.preventDefault();

    if (!this.state.isPending && !this.state.isInvalid) {
      var returnValue = this.props.onSubmit(serialize(e.target));

      if (returnValue instanceof promise$1) {
        this.setState({
          isPending: true
        });
        returnValue.catch(function (e) {
          console.log(e);
        }).then(function () {
          _this2.setState({
            isPending: false
          });
        });
      }
    }
  };

  _proto._onChange = function _onChange(e) {
    var _this3 = this;

    this.props.onChange && this.props.onChange(e);
    setTimeout(function () {
      _this3.evaluateIfError();
    }, 10);
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        onChange = _this$props.onChange,
        onSubmit = _this$props.onSubmit,
        className = _this$props.className,
        restProps = objectWithoutPropertiesLoose(_this$props, ["children", "onChange", "onSubmit", "className"]);

    return React.createElement("form", _extends_1({
      ref: this.setRef,
      noValidate: true
    }, restProps, {
      className: classList('Form', this.state.isPending && 'Form--isPending', this.state.isInvalid && 'Form--isInvalid', prefixToClasses('Form--', className)),
      onSubmit: this.onSubmit,
      onChange: this.onChange
    }), children(this.state.isPending, this.state.isInvalid));
  };

  return Form;
}(React.PureComponent);
function serialize(form) {
  return Array.prototype.reduce.call(form.querySelectorAll('[name]'), function (data, el) {
    var name = el.name,
        value = el.value;

    if (el.type === 'checkbox') {
      value = el.checked ? '1' : '0';
    }

    if (el.type === 'radio') {
      if (!el.checked) {
        return data;
      }

      value = el.value;
    }

    if (el.type === 'select-multiple') {
      value = [];

      var selectedOptions = from_1$1(el.selectedOptions);

      selectedOptions.forEach(function (option) {
        return value.push(option.value);
      });
    }

    if (el.type === 'file') {
      value = el.files.length ? el.files : null;
    }

    if (value) {
      // item[foo] â item.foo
      var nameSplit = name.match(/(.+)\[(\w+)\]$/);

      if (nameSplit) {
        var arrayIndex = nameSplit[2];
        var array = data[nameSplit[1]];

        if (arrayIndex === '0') {
          data[nameSplit[1]] = [value];
        } else if (/^\d+$/.test(arrayIndex)) {
          array.push(value);
        } else {
          if (!array) {
            data[nameSplit[1]] = {};
          }

          data[nameSplit[1]][arrayIndex] = value;
        }
      } else {
        data[name] = value;
      }
    }

    return data;
  }, {});
}

/*
 *
 * */

var InputElement = Field;
/*
 *
 * */

var Input = addWrapperToField(InputElement, 'Input');

/*
 *
 * TODO: Handle required, etc.
 * */

var RadioGroupElement =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(RadioGroupElement, _React$PureComponent);

  function RadioGroupElement(props) {
    var _this;

    _this = _React$PureComponent.call(this, props) || this;
    _this.state = {
      value: _this.props.defaultValue || ''
    };
    _this.onChange = _this._onChange.bind(assertThisInitialized(_this));
    return _this;
  }

  var _proto = RadioGroupElement.prototype;

  _proto._onChange = function _onChange(option) {
    var newValue = option.isChecked ? option.value : '';
    this.setState({
      value: newValue
    });
    this.props.onChange && this.props.onChange(newValue);
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props = this.props,
        name = _this$props.name,
        className = _this$props.className,
        options = _this$props.options,
        disabled = _this$props.disabled;
    var value = this.state.value;
    return React.createElement("div", {
      className: getFieldClasses(assign$1({}, this.props, {
        className: classList('RadioGroup', className)
      }))
    }, React.createElement("input", {
      name: name,
      value: value,
      hidden: true,
      readOnly: true
    }), options.map(function (o, i) {
      return React.createElement(Radio, {
        key: o.value,
        value: o.value,
        isChecked: value === o.value,
        onChange: _this2.onChange,
        className: "Field-el",
        disabled: disabled
      }, typeof o.label === 'function' ? o.label() : o.label);
    }));
  };

  return RadioGroupElement;
}(React.PureComponent);
/*
 *
 *
 * */

var RadioGroup =
/*#__PURE__*/
function (_addWrapperToField) {
  inheritsLoose(RadioGroup, _addWrapperToField);

  function RadioGroup(props) {
    var _this3;

    _this3 = _addWrapperToField.call(this, props) || this;
    _this3.state = {
      error: ''
    };
    _this3.onFocus = undefined;
    _this3.onBlur = undefined;
    return _this3;
  }

  var _proto2 = RadioGroup.prototype;

  _proto2.componentDidMount = function componentDidMount() {
    this.evalValidity();
  };

  _proto2._onFocus = function _onFocus() {};

  _proto2._onBlur = function _onBlur() {};

  _proto2._onChange = function _onChange(e) {
    this.evalValidity();
    this.props.onChange && this.props.onChange(e);

    if (!this.state.isDirty) {
      this.setState({
        isDirty: true
      });
    }
  };

  return RadioGroup;
}(addWrapperToField(RadioGroupElement, 'RadioGroup'));

var Radio =
/*#__PURE__*/
function (_React$PureComponent2) {
  inheritsLoose(Radio, _React$PureComponent2);

  function Radio(props) {
    var _this4;

    _this4 = _React$PureComponent2.call(this, props) || this;
    _this4.state = {
      isChecked: _this4.props.isChecked || _this4.props.defaultChecked || false
    };
    _this4.toggleSelect = debounce(_this4._toggleSelect.bind(assertThisInitialized(_this4)), 50);
    return _this4;
  }

  var _proto3 = Radio.prototype;

  _proto3.componentWillUpdate = function componentWillUpdate(nextProps) {
    if (this.props.isChecked !== nextProps.isChecked) {
      this.setState({
        isChecked: nextProps.isChecked
      });
    }
  };

  _proto3._toggleSelect = function _toggleSelect(e) {
    var isChecked = !this.state.isChecked;
    this.setState({
      isChecked: isChecked
    });
    this.props.onChange && this.props.onChange({
      value: this.props.value,
      isChecked: isChecked
    });
  };

  _proto3.render = function render() {
    var _this$props2 = this.props,
        isChecked = _this$props2.isChecked,
        disabled = _this$props2.disabled;
    return React.createElement("label", {
      className: "Field-el",
      onClick: disabled ? undefined : this.toggleSelect
    }, React.createElement("input", {
      type: "checkbox",
      checked: isChecked,
      hidden: true,
      readOnly: true,
      disabled: disabled
    }), React.createElement("span", {
      className: "Radio-mark"
    }), React.createElement("span", {
      className: "Radio-label"
    }, this.props.children));
  };

  return Radio;
}(React.PureComponent);

/*
 *
 *
 * */

var CheckboxElement =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(CheckboxElement, _React$PureComponent);

  function CheckboxElement() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto = CheckboxElement.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        className = _this$props.className,
        children = _this$props.children,
        isSwitch = _this$props.isSwitch,
        restProps = objectWithoutPropertiesLoose(_this$props, ["className", "children", "isSwitch"]);

    return React.createElement("div", {
      className: getFieldClasses(assign$1({}, this.props, {
        className: classList('Checkbox', className, isSwitch && 'Checkbox--Switch')
      }))
    }, React.createElement("label", {
      className: "Field-el"
    }, React.createElement("input", _extends_1({}, restProps, {
      type: "checkbox",
      hidden: true
    })), React.createElement("span", {
      className: "Checkbox-mark"
    }), React.createElement("span", {
      className: "Checkbox-label"
    }, children)));
  };

  return CheckboxElement;
}(React.PureComponent);
/*
 *
 *
 * */

var Checkbox = addWrapperToField(CheckboxElement, 'Checkbox');

var core_getIterator = _core.getIterator = function (it) {
  var iterFn = core_getIteratorMethod(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return _anObject(iterFn.call(it));
};

var getIterator = core_getIterator;

var getIterator$1 = getIterator;

// 7.2.2 IsArray(argument)

var _isArray = Array.isArray || function isArray(arg) {
  return _cof(arg) == 'Array';
};

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)


_export(_export.S, 'Array', { isArray: _isArray });

var isArray = _core.Array.isArray;

var isArray$1 = isArray;

var $JSON = _core.JSON || (_core.JSON = { stringify: JSON.stringify });
var stringify = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

var stringify$1 = stringify;

/*
* Handle placeholder required, etc.
* */

var SelectElement =
/*#__PURE__*/
function (_Dropdown) {
  inheritsLoose(SelectElement, _Dropdown);

  function SelectElement(props) {
    var _this;

    _this = _Dropdown.call(this, props) || this;

    _this.setRef = function (e) {
      return _this.optionsBody = e;
    };

    var selectedOption = _this.getOptionFromValue(props.defaultValue); // defaultValue = null / invalid, nothing to be selected


    _this._options = stringify$1(props.options); // One time, so no significant performance issues.

    _this.state.selectedOption = selectedOption;
    _this.state.options = JSON.parse(_this._options);
    _this.onSelect = _this._onSelect.bind(assertThisInitialized(_this));
    _this.searchInOptions = _this._searchInOptions.bind(assertThisInitialized(_this));
    _this.filterOptions = debounce(_this._filterOptions, 100);
    return _this;
  }

  var _proto = SelectElement.prototype;

  _proto.getOptionFromValue = function getOptionFromValue(val) {
    var option = null;

    for (var _iterator = this.props.options, _isArray = isArray$1(_iterator), _i = 0, _iterator = _isArray ? _iterator : getIterator$1(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var o = _ref;
      var isNested = o.options && o.options instanceof Array;

      if (isNested) {
        for (var _iterator2 = o.options, _isArray2 = isArray$1(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : getIterator$1(_iterator2);;) {
          var _ref2;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
          }

          var so = _ref2;

          if (so.value === val) {
            option = so;
            break;
          }
        }
      } else if (o.value === val) {
        option = o;
        break;
      }
    }

    return option;
  };

  _proto._onSelect = function _onSelect(option) {
    this.setState({
      selectedOption: option,
      show: false
    });
  };

  _proto._searchInOptions = function _searchInOptions(e) {
    var search = e.target.value;
    this.filterOptions(search);
  };

  _proto._filterOptions = function _filterOptions(search) {
    var options = JSON.parse(this._options);

    if (search) {
      var searchKeys = this.props.searchKeys || ['name'];
      search = search.toLowerCase();
      options = options.filter(function (o) {
        var _loop2 = function _loop2() {
          if (_isArray3) {
            if (_i3 >= _iterator3.length) return "break";
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) return "break";
            _ref3 = _i3.value;
          }

          var k = _ref3;
          var isNested = o.options && o.options instanceof Array;

          if (isNested) {
            if (!o.options.length) {
              return {
                v: false
              };
            }

            var subOptions = o.options.filter(function (so) {
              if (so.hasOwnProperty(k) && so[k].toLowerCase().indexOf(search) > -1) {
                return true;
              }
            });

            if (subOptions.length) {
              o.options = subOptions;
              return {
                v: true
              };
            }

            return {
              v: false
            };
          } else {
            if (o.hasOwnProperty(k) && o[k].toLowerCase().indexOf(search) > -1) {
              return {
                v: true
              };
            }
          }
        };

        _loop: for (var _iterator3 = searchKeys, _isArray3 = isArray$1(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : getIterator$1(_iterator3);;) {
          var _ref3;

          var _ret = _loop2();

          switch (_ret) {
            case "break":
              break _loop;

            default:
              if (typeof _ret === "object") return _ret.v;
          }
        }
      });
    }

    this.setState({
      options: options
    });
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props = this.props,
        name = _this$props.name,
        className = _this$props.className,
        disabled = _this$props.disabled,
        beforeOptions = _this$props.beforeOptions,
        afterOptions = _this$props.afterOptions,
        enableSearch = _this$props.enableSearch;
    var _this$state = this.state,
        options = _this$state.options,
        selectedOption = _this$state.selectedOption,
        show = _this$state.show;
    return React.createElement(OutsideClickLayer, {
      onOutsideClick: function onOutsideClick(_) {
        return _this2.setState({
          show: false
        });
      },
      enabled: true
    }, React.createElement("div", {
      className: getFieldClasses(assign$1({}, this.props, {
        className: classList('Select', show && 'Select--show', className)
      }))
    }, React.createElement("input", {
      name: name,
      value: selectedOption ? selectedOption.value : '',
      hidden: true,
      readOnly: true
    }), React.createElement("div", {
      className: "Field-el Select-trigger",
      onClick: disabled ? undefined : this.toggleDropdown
    }, selectedOption && React.createElement(SelectedOption, {
      option: selectedOption
    })), show && React.createElement(DropdownOptions, {
      elRef: this.setRef,
      closeDropdown: this.closeDropdown,
      beforeOptions: enableSearch ? React.createElement(InputElement, {
        onChange: this.searchInOptions,
        autoFocus: true
      }) : beforeOptions,
      afterOptions: afterOptions
    }, React.createElement(Options, {
      options: options,
      highlightOption: selectedOption,
      onSelect: disabled ? undefined : this.onSelect
    }))));
  };

  return SelectElement;
}(Dropdown);
/*
 *
 *
 * */

var Select = addWrapperToField(SelectElement, 'Select');

var SelectedOption =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(SelectedOption, _React$PureComponent);

  function SelectedOption() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto2 = SelectedOption.prototype;

  _proto2.render = function render() {
    var option = this.props.option;
    return React.createElement("div", {
      className: "SelectedOption"
    }, option.name);
  };

  return SelectedOption;
}(React.PureComponent);

var Options =
/*#__PURE__*/
function (_React$PureComponent2) {
  inheritsLoose(Options, _React$PureComponent2);

  function Options() {
    var _this3;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this3 = _React$PureComponent2.call.apply(_React$PureComponent2, [this].concat(args)) || this;
    _this3.handleSelect = _this3._handleSelect.bind(assertThisInitialized(_this3));
    return _this3;
  }

  var _proto3 = Options.prototype;

  _proto3._handleSelect = function _handleSelect(option) {
    this.props.onSelect(option);
  };

  _proto3.getOption = function getOption(key, o, highlightOption) {
    var _this4 = this;

    return React.createElement(DropdownItem, {
      key: key,
      className: classList('Select-Option', highlightOption === o && 'Select-Option--highlight'),
      onClick: function onClick(_) {
        return _this4.handleSelect(o);
      }
    }, o.name);
  };

  _proto3.render = function render() {
    var _this5 = this;

    var _this$props2 = this.props,
        options = _this$props2.options,
        highlightOption = _this$props2.highlightOption;
    return options.map(function (o, ix) {
      var isNested = o.options && o.options instanceof Array;
      var opt;

      if (isNested) {
        if (!o.options.length) {
          return;
        }

        opt = React.createElement("div", {
          className: "Select-Option-group",
          key: o.label
        }, React.createElement("div", {
          className: "Select-Option-label"
        }, o.label), o.options.map(function (oy, iy) {
          return _this5.getOption('' + ix + iy, oy, highlightOption);
        }));
      } else {
        opt = _this5.getOption(ix, o, highlightOption);
      }

      return opt;
    });
  };

  return Options;
}(React.PureComponent);

/*
 *
 *
 * */

var SmoothScrollLink =
/*#__PURE__*/
function (_React$PureComponent) {
  inheritsLoose(SmoothScrollLink, _React$PureComponent);

  function SmoothScrollLink() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;

    _this.scrollToHash = function (e) {
      scrollToHash(e, _this.props.to);
    };

    return _this;
  }

  var _proto = SmoothScrollLink.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        to = _this$props.to,
        className = _this$props.className,
        children = _this$props.children;
    return React.createElement("a", {
      href: to,
      className: classList('SmoothScroll', className //  No prefixToClasses here
      ),
      onClick: this.scrollToHash
    }, children);
  };

  return SmoothScrollLink;
}(React.PureComponent);

/*
 *
 * */

var ErrorBoundary =
/*#__PURE__*/
function (_React$Component) {
  inheritsLoose(ErrorBoundary, _React$Component);

  function ErrorBoundary(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      hasError: false
    };
    return _this;
  }

  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return {
      hasError: true
    };
  };

  var _proto = ErrorBoundary.prototype;

  _proto.componentDidCatch = function componentDidCatch(error, info) {
    console.log('Catch error in Error Boundary..', error, info); // reportStackTrace(error, info); // TODO: Log the stack trace
  };

  _proto.render = function render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return React.createElement("div", {
        className: "ErrorBoundary"
      }, "Error Boundary render()", React.createElement("br", null), "Something went Wrong. This will be fixed shortly :)");
    }

    return this.props.children;
  };

  return ErrorBoundary;
}(React.Component);

/*
*
* Note:
* 1. Following components needs to be imported manually, as they need image/svg loader.
* 2. SocialMeta needs image loader, however, BasicMeta is opted out to keep it consistent in import as SocialMeta
* 3. Icon need svg loader, and bundle all assets is not possible, it's good to import it separately so that only the used svg assets are bundled.
* */

/*
  export { BasicMeta } from './Meta/BasicMeta';
  export { SocialMeta } from './Meta/SocialMeta';
  export Icon from './Icon/Icon';
*/

export { AsyncButton, AutoRemoveLayer, BackDrop, Banner, Button, Card, Checkbox, CheckboxElement, ClipboardWithButton, ClipboardWithTooltip, Dropdown, DropdownItem, ErrorBoundary, EscPressLayer, Form, GhostLoader, HelpText, Input, InputElement, NotificationsContainer, OutsideClickLayer, Popover, PopupsContainer, RadioGroup, RadioGroupElement, RipplePointer, Select, SelectElement, SmoothScrollLink, Spinner, Tag, TagsList, Textarea, TextareaElement, ToastsContainer, Tooltip, openConfirmPopup, openNotification, openPopup, openToast };
//# sourceMappingURL=index.min.js.map
